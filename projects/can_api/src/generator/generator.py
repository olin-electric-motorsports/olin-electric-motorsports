import cantools
import os
import yaml
import subprocess
from pathlib import Path

NUM_MSGS = lambda msgs: len(msgs) - 1
RAW_ARR_NAME = lambda msg: msg.upper() + "_RAW_ARR"
STRUCT_NAME = lambda msg: msg.upper() + "_MSG"
TEMPLATE_SEPARATOR = "######\n"
#TODO
#define CAN_ENABLED      0x00
#define CAN_DISABLED     0x01
#define CAN_LISTEN       0x02


class Utils:
    def __init__(self, file_name):
        self.name = file_name

    def generate(self, msgs):
        #child classes override this
        return ""

    def edit_file(self, msgs):
        #open the file or create it if it doesn't exist already
        save_path = os.path.join("./out", self.name)
        f = Path(save_path)
        f.touch(exist_ok=True)
        with open(save_path, "r") as f:
            c_file = f.read()

        #update the file with the new body
        with open(save_path, "w") as f:
            f.write(self.generate(msgs))
        print(f"updated {self.name}")

    def read_template(self, file):
        with open(file, "r") as f:
            return f.read()


class HeaderGenerator(Utils):
    def __init__(self, file_name):
        super().__init__(file_name=f"{file_name}_generated.h")
        self.prefix = file_name

    def generate(self, msgs):
        """
        Add board_CAN_init and initialize message_specific variables
        """
        header_str = self.read_template("./templates/h_file.txt").format(
            prefix=self.prefix,
            setters=self._define_setters(msgs)
        )
        return header_str

    def _define_setters(self, msgs):
        template = self.read_template("./templates/h_setters.txt")
        final_str = ""
        for msg, msg_info in msgs.items():
            if msg == "receivers":
                continue
            sig_str = ""
            for sig in msg_info["signals"].keys():
                final_str += template.format(msg=msg, sig=sig)
        return final_str


class CGenerator(Utils):
    def __init__(self, file_name):
        super().__init__(file_name=f"{file_name}_generated.c")
        self.prefix = file_name

    def _generate_can_arr(self, msgs):
        final_str = ""
        i = 0
        template = self.read_template("./templates/generate_can_arr.txt")
        for msg_name, msg_info in msgs.items():
            if msg_name == "receivers":
                continue
            #add naming to message name
            final_str += template.format(
                msg_name=msg_name.upper(),
                arr_name=RAW_ARR_NAME(msg_name),
                cycle_time=msg_info["frequency"],
                i=i,
                msg_id=msg_info["id"],
                msg_length=msg_info["data_bytes"]
            )
            i += 1
        return final_str

    def _generate_structs(self, msgs):
        template = self.read_template("./templates/generate_msg_structs.txt")
        def_temp, sig_temp = template.split(TEMPLATE_SEPARATOR)
        init_str, def_str = "", ""
        for msg, msg_info in msgs.items():
            if msg == "receivers":
                continue
            #create string that defines the structs, TODO make sure that struct type always matches type generated by cantools
            sigs = msg_info["signals"]
            sig_str = ""
            for signal in sigs.keys():
                sig_str += sig_temp.format(signal=signal)
                #test that the naming scheme matches the cantools one
            def_str += def_temp.format(
                struct_type=f"{self.prefix}_{msg}_t",
                struct_name=STRUCT_NAME(msg),
                signals=sig_str
            )
            

        return def_str

    def _generate_setters(self, msgs):
        final_str = ""
        template = self.read_template("./templates/c_setters.txt")
        for msg, msg_info in msgs.items():
            if msg == "receivers":
                continue
            sig_str = ""
            for sig in msg_info["signals"].keys():
                final_str += template.format(
                    msg=msg,
                    sig=sig,
                    prefix=self.prefix,
                    msg_raw=RAW_ARR_NAME(msg),
                    msg_struct=STRUCT_NAME(msg)
                )
        return final_str

    def _raw_array_defs(self, msgs):
        #initialize structs and raw arrays here, remove them from the header file
        header_str = ""
        template = self.read_template("./templates/raw_array_defs.txt")
        for msg_name in msgs.keys():
            if msg_name == "receivers":
                continue
            header_str += template.format(arr_name=RAW_ARR_NAME(msg_name))
        return header_str            

    def generate(self, msgs):
        #generate the entire can_msg_info array, leaving the raw_arr empty
        #use a list of all outgoing messages in PYTHON to determine this order.
        #generate a str array of the outgoing message names in C as well. Use this to fill in the RAW_ARR once each has been malloc'd..
        struct_definition = self._generate_structs(msgs)
        func_body = self.read_template("./templates/c_file.txt").format(
            prefix=self.prefix, 
            can_arr=self._generate_can_arr(msgs),
            struct_defs=struct_definition,
            NUM_MSGS=NUM_MSGS(msgs), 
            setters=self._generate_setters(msgs),
            raw_arrays=self._raw_array_defs(msgs),
            mode=0 #TODO define mode macros like above 0= 1= 2=
        )
        return func_body

def main(file_prefix):
    """
    TODO
    """
    #load the cantools file
    dbc_path = f'../dbc/{file_prefix}.dbc'
    db = cantools.database.load_file(dbc_path)
    out = subprocess.run(['cantools', 'generate_c_source', '--no-floating-point-numbers', dbc_path])

    #open the yaml file
    with open(f"../mini_yamls/{file_prefix}.yaml", 'r') as f:
        data = yaml.load(f, yaml.FullLoader)

    # move generated files to ./out folder
    Path("./out").mkdir(exist_ok=True)
    os.replace(f"{file_prefix}.c", f"./out/{file_prefix}.c")
    os.replace(f"{file_prefix}.h", f"./out/{file_prefix}.h")
    
    msgs = data["MessagesTX"]
    if NUM_MSGS(msgs) > 6:
        print("this mini YAML has more than the maximum 6 messages.")
        return

    c_gen = CGenerator(file_prefix)
    c_gen.edit_file(msgs)

    header = HeaderGenerator(file_prefix)
    header.edit_file(msgs)


if __name__ == "__main__":
    main("shutdown")    #generate file based on the shutdown mini_yaml